{"ast":null,"code":"import _initializerDefineProperty from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec,\n    _class,\n    _descriptor,\n    _temp,\n    _class3,\n    _class4,\n    _temp2,\n    _jsxFileName = \"/Users/meng/www/tp5/JS/react.js/myapp/src/mobx/index.js\";\n\nimport React, { Component, Fragment } from \"react\";\nimport PropTypes from 'prop-types';\nimport { observable, action, isArrayLike, computed, autorun, when, reaction, runInAction } from 'mobx';\nimport { observer, PropTypes as observablePropTypes } from 'mobx-react';\n/*\n// decoraotr 修饰符\nfunction log(target) {//target就是类\n    const desc = Object.getOwnPropertyDescriptors(target.prototype)\n    for(const key of Object.keys(desc)){\n        if(key === 'constructor'){\n            continue\n        }\n        const func = desc[key].value\n        if('function' === typeof func){\n            Object.defineProperty(target.prototype, key, {\n                value(...args){\n                    console.log('before '+ key)\n                    const ret = func.apply(this, args)\n                    console.log(ret);\n                    return ret;\n                    console.log('after '+ key)\n                }\n            })\n        }\n    }\n}\nfunction readonly(target, key, descriptor) {\n    descriptor.writable = false;\n    // console.log(target);\n    // console.log(key);\n    // console.log(descriptor);\n}\nfunction validate(target, key, descriptor) {\n    const func = descriptor.value\n    descriptor.value = function (...args) {\n        for(let num of args){\n            if('number' !== typeof num){\n                // throw new Error(`\"${num}\" is not a number`)\n                console.error(`\"${num}\" is not a number`)\n            }\n        }\n        return func.apply(this, args)\n    }\n}\n@log\nclass Numberic {\n    @readonly PI = 3.141592654;\n    @validate\n    add(...nums){\n        return nums.reduce((p,n)=>(p+n),0);\n    }\n}\nnew Numberic().add(1,2,'fjj');\n// new Numberic().PI = 111;\n*/\n\nconst arr = observable([1, 2, 3, 4]);\nconsole.log(arr);\nconst obj = observable({\n  name: 'mxq',\n  title: 'fjeowj'\n});\nconst map = observable(new Map());\nconst num = observable.box(20);\nconst str = observable.box('jfaweio');\nconst bool = observable.box(true);\nnum.set(50);\nconsole.log(num.get());\n/*\nclass Test{\n    @observable arr = [];\n    @observable obj = {};\n    @observable map = new Map();\n    @observable num = 20;\n    @observable str = 'hello';\n    @observable bol = false;\n    // 方法二：直接用修饰器语法使用，通过这个方法，只能得到最终的计算值，不能获取observe的方法了\n    @computed get mixed(){\n        return te.str+'--'+te.num\n    }\n    @action bar() {\n        this.str = 'm';\n        this.num = 168;\n    }\n}\n\nconst te = new Test();\n// 方法一：\n// var foo = computed(()=> te.str+'/'+te.num)//拼接被观察的两个数据\n// foo.observe((change)=>{\n//      数据改变时调用此方法\n//      console.log( change);\n// });\n// te.str = 'word';\n// console.log(foo.get());\n\n// 初始化会自动运行，修改autorun中任意可观察数据可触发aoturun\nautorun(()=>{\n    // console.log(te.mixed);\n});\n\n// when 接收两个函数，第一个为布尔值，当只有第一个为true的时候，才会执行第二个函数，并且保证最多只被执行一次。\n// TUDU: 第一个参数为布尔值，必须是一个可观察数据，不能根据普通变量\n// TUDO: 如果一开始就返回真，那么第二个函数会同步立即执行\nwhen(() => te.bol, () => console.log(\"it's true\"));\nte.bol = true; // \"it's true\"\n// 当引入的可观察数据发生变化时，触发第二个函数\nreaction(()=>[te.str, te.num, te.bol], (arr)=>{\n    console.log(arr);\n})\n// 使用runInAction方法，同样只会触发一次\nrunInAction(() => {\n    te.str = 'm';\n    te.num = 168;\n})\n// te.str = 'word';\n// te.num = 50;\n// te.bar()\n*/\n\nlet Store = (_dec = action.bound, (_class = (_temp = class Store {\n  constructor() {\n    _initializerDefineProperty(this, \"cache\", _descriptor, this);\n  }\n\n  refresh() {\n    this.cache.queue.push(1);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"cache\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {\n      queue: []\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"refresh\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"refresh\"), _class.prototype)), _class));\nconst store = new Store();\n\nlet //修饰类本身\nBar = observer(_class3 = (_temp2 = _class4 = class Bar extends Component {\n  render() {\n    const queue = this.props.queue;\n    return React.createElement(Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 140\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 141\n      },\n      __self: this\n    }, queue.length), React.createElement(\"button\", {\n      onClick: this.props.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 142\n      },\n      __self: this\n    }, \"refresh\"));\n  }\n\n}, _class4.propTypes = {\n  queue: observablePropTypes.observableArray //PropTypes.array\n\n}, _temp2)) || _class3;\n\nclass Foo extends Component {\n  render() {\n    const cache = this.props.cache;\n    return React.createElement(Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 155\n      },\n      __self: this\n    }, React.createElement(Bar, {\n      queue: cache.queue,\n      refresh: this.props.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 156\n      },\n      __self: this\n    }));\n  }\n\n}\n\nFoo.propTypes = {\n  cache: observablePropTypes.observableObject //PropTypes.object\n\n};\n\nclass TodoList extends Component {\n  render() {\n    return React.createElement(Foo, {\n      cache: store.cache,\n      refresh: store.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 166\n      },\n      __self: this\n    });\n  }\n\n}\n\nexport default TodoList;","map":{"version":3,"sources":["/Users/meng/www/tp5/JS/react.js/myapp/src/mobx/index.js"],"names":["React","Component","Fragment","PropTypes","observable","action","isArrayLike","computed","autorun","when","reaction","runInAction","observer","observablePropTypes","arr","console","log","obj","name","title","map","Map","num","box","str","bool","set","get","Store","bound","refresh","cache","queue","push","store","Bar","render","props","length","propTypes","observableArray","Foo","observableObject","TodoList"],"mappings":"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","sourcesContent":["import React, {Component, Fragment} from \"react\";\nimport PropTypes from 'prop-types'\nimport { observable, action, isArrayLike, computed, autorun, when, reaction, runInAction} from 'mobx'\n\nimport {observer, PropTypes as observablePropTypes} from 'mobx-react'\n\n\n\n/*\n// decoraotr 修饰符\nfunction log(target) {//target就是类\n    const desc = Object.getOwnPropertyDescriptors(target.prototype)\n    for(const key of Object.keys(desc)){\n        if(key === 'constructor'){\n            continue\n        }\n        const func = desc[key].value\n        if('function' === typeof func){\n            Object.defineProperty(target.prototype, key, {\n                value(...args){\n                    console.log('before '+ key)\n                    const ret = func.apply(this, args)\n                    console.log(ret);\n                    return ret;\n                    console.log('after '+ key)\n                }\n            })\n        }\n    }\n}\nfunction readonly(target, key, descriptor) {\n    descriptor.writable = false;\n    // console.log(target);\n    // console.log(key);\n    // console.log(descriptor);\n}\nfunction validate(target, key, descriptor) {\n    const func = descriptor.value\n    descriptor.value = function (...args) {\n        for(let num of args){\n            if('number' !== typeof num){\n                // throw new Error(`\"${num}\" is not a number`)\n                console.error(`\"${num}\" is not a number`)\n            }\n        }\n        return func.apply(this, args)\n    }\n}\n@log\nclass Numberic {\n    @readonly PI = 3.141592654;\n    @validate\n    add(...nums){\n        return nums.reduce((p,n)=>(p+n),0);\n    }\n}\nnew Numberic().add(1,2,'fjj');\n// new Numberic().PI = 111;\n*/\n\nconst arr = observable([1,2,3,4]);\nconsole.log(arr);\nconst obj = observable({name: 'mxq', title: 'fjeowj'});\nconst map = observable(new Map());\n\nconst num = observable.box(20);\nconst str = observable.box('jfaweio');\nconst bool = observable.box(true);\nnum.set(50);\nconsole.log(num.get());\n\n/*\nclass Test{\n    @observable arr = [];\n    @observable obj = {};\n    @observable map = new Map();\n    @observable num = 20;\n    @observable str = 'hello';\n    @observable bol = false;\n    // 方法二：直接用修饰器语法使用，通过这个方法，只能得到最终的计算值，不能获取observe的方法了\n    @computed get mixed(){\n        return te.str+'--'+te.num\n    }\n    @action bar() {\n        this.str = 'm';\n        this.num = 168;\n    }\n}\n\nconst te = new Test();\n// 方法一：\n// var foo = computed(()=> te.str+'/'+te.num)//拼接被观察的两个数据\n// foo.observe((change)=>{\n//      数据改变时调用此方法\n//      console.log( change);\n// });\n// te.str = 'word';\n// console.log(foo.get());\n\n// 初始化会自动运行，修改autorun中任意可观察数据可触发aoturun\nautorun(()=>{\n    // console.log(te.mixed);\n});\n\n// when 接收两个函数，第一个为布尔值，当只有第一个为true的时候，才会执行第二个函数，并且保证最多只被执行一次。\n// TUDU: 第一个参数为布尔值，必须是一个可观察数据，不能根据普通变量\n// TUDO: 如果一开始就返回真，那么第二个函数会同步立即执行\nwhen(() => te.bol, () => console.log(\"it's true\"));\nte.bol = true; // \"it's true\"\n// 当引入的可观察数据发生变化时，触发第二个函数\nreaction(()=>[te.str, te.num, te.bol], (arr)=>{\n    console.log(arr);\n})\n// 使用runInAction方法，同样只会触发一次\nrunInAction(() => {\n    te.str = 'm';\n    te.num = 168;\n})\n// te.str = 'word';\n// te.num = 50;\n// te.bar()\n*/\n\nclass Store {\n    @observable cache = {queue: []}\n    @action.bound refresh(){\n        this.cache.queue.push(1)\n    }\n}\nconst store = new Store();\n\n@observer //修饰类本身\nclass Bar extends Component{\n    static propTypes = {\n        queue: observablePropTypes.observableArray  //PropTypes.array\n    }\n    render(){\n        const queue = this.props.queue;\n        return (\n            <Fragment>\n                <span>{queue.length}</span>\n                <button onClick={this.props.refresh}>refresh</button>\n            </Fragment>\n        )\n    }\n}\n\nclass Foo extends Component{\n    static propTypes = {\n        cache: observablePropTypes.observableObject  //PropTypes.object\n    }\n    render(){\n        const cache = this.props.cache;\n        return (\n            <Fragment>\n                <Bar queue={cache.queue} refresh={this.props.refresh}/>\n            </Fragment>\n        )\n    }\n}\n\nclass TodoList extends Component{\n\n    render(){\n        return (\n            <Foo cache={store.cache} refresh={store.refresh}/>\n        )\n    }\n}\n\nexport default TodoList;\n\n"]},"metadata":{},"sourceType":"module"}