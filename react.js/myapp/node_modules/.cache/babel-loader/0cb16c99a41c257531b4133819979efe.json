{"ast":null,"code":"import _initializerDefineProperty from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/Users/meng/www/tp5/JS/react.js/myapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class,\n    _descriptor,\n    _descriptor2,\n    _descriptor3,\n    _descriptor4,\n    _descriptor5,\n    _descriptor6,\n    _temp,\n    _dec,\n    _class3,\n    _descriptor7,\n    _temp2,\n    _class5,\n    _class6,\n    _temp3,\n    _jsxFileName = \"/Users/meng/www/tp5/JS/react.js/myapp/src/mobx/index.js\";\n\nimport React, { Component, Fragment } from \"react\";\nimport PropTypes from 'prop-types';\nimport { observable, action, isArrayLike, computed, autorun, when, reaction, runInAction } from 'mobx';\nimport { observer, PropTypes as observablePropTypes } from 'mobx-react';\n/*\n// decoraotr 修饰符\nfunction log(target) {//target就是类\n    const desc = Object.getOwnPropertyDescriptors(target.prototype)\n    for(const key of Object.keys(desc)){\n        if(key === 'constructor'){\n            continue\n        }\n        const func = desc[key].value\n        if('function' === typeof func){\n            Object.defineProperty(target.prototype, key, {\n                value(...args){\n                    console.log('before '+ key)\n                    const ret = func.apply(this, args)\n                    console.log(ret);\n                    return ret;\n                    console.log('after '+ key)\n                }\n            })\n        }\n    }\n}\nfunction readonly(target, key, descriptor) {\n    descriptor.writable = false;\n    // console.log(target);\n    // console.log(key);\n    // console.log(descriptor);\n}\nfunction validate(target, key, descriptor) {\n    const func = descriptor.value\n    descriptor.value = function (...args) {\n        for(let num of args){\n            if('number' !== typeof num){\n                // throw new Error(`\"${num}\" is not a number`)\n                console.error(`\"${num}\" is not a number`)\n            }\n        }\n        return func.apply(this, args)\n    }\n}\n@log\nclass Numberic {\n    @readonly PI = 3.141592654;\n    @validate\n    add(...nums){\n        return nums.reduce((p,n)=>(p+n),0);\n    }\n}\nnew Numberic().add(1,2,'fjj');\n// new Numberic().PI = 111;\n*/\n// const arr = observable([1,2,3,4]);\n// const obj = observable({name: 'mxq', title: 'fjeowj'});\n// const map = observable(new Map());\n//number string bool必须用 observable.box\n// const num = observable.box(20);\n// const str = observable.box('jfaweio');\n// const bool = observable.box(true);\n// num.set(50);\n// console.log(num.get());\n\nlet Test = (_class = (_temp = class Test {\n  constructor() {\n    _initializerDefineProperty(this, \"arr\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"obj\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"map\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"num\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"str\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"bol\", _descriptor6, this);\n  } // 方法二：直接用修饰器语法使用，通过这个方法，只能得到最终的计算值，不能获取observe的方法了\n  // @computed get mixed(){\n  //     return te.str+'--'+te.num\n  // }\n  // @action bar() {\n  //     this.str = 'm';\n  //     this.num = 168;\n  // }\n\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"arr\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return [];\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"obj\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {};\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"map\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return new Map();\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"num\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 20;\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"str\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 'hello';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"bol\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n})), _class);\nconst te = new Test(); // 方法一：\n// var foo = computed(()=> te.str+'/'+te.num)//拼接被观察的两个数据\n// foo.observe((change)=>{\n//      数据改变时调用此方法\n//      console.log( change);\n// });\n// te.str = 'word';\n// console.log(foo.get());\n// 初始化会自动运行，修改autorun中任意可观察数据可触发aoturun\n\nautorun(() => {// console.log(te.mixed);\n}); // when 接收两个函数，第一个为布尔值，当只有第一个为true的时候，才会执行第二个函数，并且保证最多只被执行一次。\n// TUDU: 第一个参数为布尔值，必须是一个可观察数据，不能根据普通变量\n// TUDO: 如果一开始就返回真，那么第二个函数会同步立即执行\n\nwhen(() => te.bol, () => console.log(\"it's true\"));\nte.bol = true; // \"it's true\"\n// 当引入的可观察数据发生变化时，触发第二个函数\n\nreaction(() => [te.str, te.num, te.bol], arr => {\n  console.log(arr);\n}); // 使用runInAction方法，同样只会触发一次\n\nrunInAction(() => {\n  te.str = 'm';\n  te.num = 168;\n}); // te.str = 'word';\n// te.num = 50;\n// te.bar()\n\nlet Store = (_dec = action.bound, (_class3 = (_temp2 = class Store {\n  constructor() {\n    _initializerDefineProperty(this, \"cache\", _descriptor7, this);\n  }\n\n  refresh() {\n    this.cache.queue.push(1);\n  }\n\n}, _temp2), (_descriptor7 = _applyDecoratedDescriptor(_class3.prototype, \"cache\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {\n      queue: []\n    };\n  }\n}), _applyDecoratedDescriptor(_class3.prototype, \"refresh\", [_dec], Object.getOwnPropertyDescriptor(_class3.prototype, \"refresh\"), _class3.prototype)), _class3));\nconst store = new Store();\n\nlet //修饰类本身\nBar = observer(_class5 = (_temp3 = _class6 = class Bar extends Component {\n  render() {\n    const queue = this.props.queue;\n    return React.createElement(Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 142\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 143\n      },\n      __self: this\n    }, queue.length), React.createElement(\"button\", {\n      onClick: this.props.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144\n      },\n      __self: this\n    }, \"refresh\"));\n  }\n\n}, _class6.propTypes = {\n  queue: observablePropTypes.observableArray //PropTypes.array\n\n}, _temp3)) || _class5;\n\nclass Foo extends Component {\n  render() {\n    const cache = this.props.cache;\n    return React.createElement(Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 157\n      },\n      __self: this\n    }, React.createElement(Bar, {\n      queue: cache.queue,\n      refresh: this.props.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 158\n      },\n      __self: this\n    }));\n  }\n\n}\n\nFoo.propTypes = {\n  cache: observablePropTypes.observableObject //PropTypes.object\n\n};\n\nclass TodoList extends Component {\n  render() {\n    return React.createElement(Foo, {\n      cache: store.cache,\n      refresh: store.refresh,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168\n      },\n      __self: this\n    });\n  }\n\n}\n\nexport default TodoList;","map":{"version":3,"sources":["/Users/meng/www/tp5/JS/react.js/myapp/src/mobx/index.js"],"names":["React","Component","Fragment","PropTypes","observable","action","isArrayLike","computed","autorun","when","reaction","runInAction","observer","observablePropTypes","Test","Map","te","bol","console","log","str","num","arr","Store","bound","refresh","cache","queue","push","store","Bar","render","props","length","propTypes","observableArray","Foo","observableObject","TodoList"],"mappings":"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","sourcesContent":["import React, {Component, Fragment} from \"react\";\nimport PropTypes from 'prop-types'\nimport { observable, action, isArrayLike, computed, autorun, when, reaction, runInAction} from 'mobx'\n\nimport {observer, PropTypes as observablePropTypes} from 'mobx-react'\n\n\n\n/*\n// decoraotr 修饰符\nfunction log(target) {//target就是类\n    const desc = Object.getOwnPropertyDescriptors(target.prototype)\n    for(const key of Object.keys(desc)){\n        if(key === 'constructor'){\n            continue\n        }\n        const func = desc[key].value\n        if('function' === typeof func){\n            Object.defineProperty(target.prototype, key, {\n                value(...args){\n                    console.log('before '+ key)\n                    const ret = func.apply(this, args)\n                    console.log(ret);\n                    return ret;\n                    console.log('after '+ key)\n                }\n            })\n        }\n    }\n}\nfunction readonly(target, key, descriptor) {\n    descriptor.writable = false;\n    // console.log(target);\n    // console.log(key);\n    // console.log(descriptor);\n}\nfunction validate(target, key, descriptor) {\n    const func = descriptor.value\n    descriptor.value = function (...args) {\n        for(let num of args){\n            if('number' !== typeof num){\n                // throw new Error(`\"${num}\" is not a number`)\n                console.error(`\"${num}\" is not a number`)\n            }\n        }\n        return func.apply(this, args)\n    }\n}\n@log\nclass Numberic {\n    @readonly PI = 3.141592654;\n    @validate\n    add(...nums){\n        return nums.reduce((p,n)=>(p+n),0);\n    }\n}\nnew Numberic().add(1,2,'fjj');\n// new Numberic().PI = 111;\n*/\n\n// const arr = observable([1,2,3,4]);\n// const obj = observable({name: 'mxq', title: 'fjeowj'});\n// const map = observable(new Map());\n\n//number string bool必须用 observable.box\n// const num = observable.box(20);\n// const str = observable.box('jfaweio');\n// const bool = observable.box(true);\n// num.set(50);\n// console.log(num.get());\n\n\nclass Test{\n    @observable arr = [];\n    @observable obj = {};\n    @observable map = new Map();\n    @observable num = 20;\n    @observable str = 'hello';\n    @observable bol = false;\n    // 方法二：直接用修饰器语法使用，通过这个方法，只能得到最终的计算值，不能获取observe的方法了\n    // @computed get mixed(){\n    //     return te.str+'--'+te.num\n    // }\n    // @action bar() {\n    //     this.str = 'm';\n    //     this.num = 168;\n    // }\n}\n\nconst te = new Test();\n// 方法一：\n// var foo = computed(()=> te.str+'/'+te.num)//拼接被观察的两个数据\n// foo.observe((change)=>{\n//      数据改变时调用此方法\n//      console.log( change);\n// });\n// te.str = 'word';\n// console.log(foo.get());\n\n// 初始化会自动运行，修改autorun中任意可观察数据可触发aoturun\nautorun(()=>{\n    // console.log(te.mixed);\n});\n\n// when 接收两个函数，第一个为布尔值，当只有第一个为true的时候，才会执行第二个函数，并且保证最多只被执行一次。\n// TUDU: 第一个参数为布尔值，必须是一个可观察数据，不能根据普通变量\n// TUDO: 如果一开始就返回真，那么第二个函数会同步立即执行\nwhen(() => te.bol, () => console.log(\"it's true\"));\nte.bol = true; // \"it's true\"\n// 当引入的可观察数据发生变化时，触发第二个函数\nreaction(()=>[te.str, te.num, te.bol], (arr)=>{\n    console.log(arr);\n})\n// 使用runInAction方法，同样只会触发一次\nrunInAction(() => {\n    te.str = 'm';\n    te.num = 168;\n})\n// te.str = 'word';\n// te.num = 50;\n// te.bar()\n\n\n\n\nclass Store {\n    @observable cache = {queue: []}\n    @action.bound refresh(){\n        this.cache.queue.push(1)\n    }\n}\nconst store = new Store();\n\n@observer //修饰类本身\nclass Bar extends Component{\n    static propTypes = {\n        queue: observablePropTypes.observableArray  //PropTypes.array\n    }\n    render(){\n        const queue = this.props.queue;\n        return (\n            <Fragment>\n                <span>{queue.length}</span>\n                <button onClick={this.props.refresh}>refresh</button>\n            </Fragment>\n        )\n    }\n}\n\nclass Foo extends Component{\n    static propTypes = {\n        cache: observablePropTypes.observableObject  //PropTypes.object\n    }\n    render(){\n        const cache = this.props.cache;\n        return (\n            <Fragment>\n                <Bar queue={cache.queue} refresh={this.props.refresh}/>\n            </Fragment>\n        )\n    }\n}\n\nclass TodoList extends Component{\n\n    render(){\n        return (\n            <Foo cache={store.cache} refresh={store.refresh}/>\n        )\n    }\n}\n\nexport default TodoList;\n\n"]},"metadata":{},"sourceType":"module"}