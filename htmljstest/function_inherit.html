<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>构造函数继承</title>
</head>
<body>
<script>
    // //构造函数静态属性，方法
    // function Foo() {
    // }
    // Foo.title = 'dog';
    // Foo.eat = function () {
    //     // 静态方法
    //     console.log(Foo.title+'吃粮食');
    // }
    // console.log(Foo.title);
    // console.log(Foo.eat());



    //构造函数继承
    function Animal(){
        this.species = "动物";
    }
    function Cat(name,color){
        // Animal.apply(this, arguments)//调用Animal 改变animal内部this指向为cat
        this.name = name;
        this.color = color;
    }
    // Cat.prototype = Animal.prototype;
    Cat.prototype.constructor = Cat;//Animal.prototype.species = "动物";

    var cat1 = new Cat("大毛","黄色");

    console.log(cat1.species); // 动物



    // 总结
    // 1. constructor属性会在函数声明时默认生成。在利用new创建对象实例时，对象实例本身并没有constructor属性，但对象实例的__proto__属性和Foo.prototype属性关联，形成原型链，因此会通过原型链找到Foo.prototype.constructor属性，并以此为值。
    // 2. prototype属性可能会被重写，重写后，原来的constructor会发生改变。如果显示为constructor赋值，可以纠正。
    // 3. 因为constructor的属性很随意，所以慎用。
        // function Foo() { /* .. */ }
        // Foo.prototype.bar = function(){};
        // var a1 = new Foo();
        // // a1.constructor === Foo; // true!
        // console.log(Foo);//a1.constructor === Foo
        // console.log(a1);
        // console.log(a1.constructor);
        // console.log(Foo.prototype.constructor);

        // 改变了Foo.prototype的定义，那么a1.constructor的指向就改变了
        // function Foo() { /* .. */ }
        // Foo.prototype = { /* .. */ }; // 创建一个新原型对象
        // var a1 = new Foo();
        // a1.constructor === Foo; // false!
        // a1.constructor === Object; // true!

</script>
</body>
</html>
